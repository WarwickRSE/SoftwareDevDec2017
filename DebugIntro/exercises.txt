DebugIntro
		
01 RoundingAndTruncation.c/.f90:	
	This demonstrates how single and double precision floats can be inexact, and what this can do unexpectedly
	Try the program with a few optimisation levels etc, as this can sometimes change things. 
	Notice:
		the double version of pi is correct to about 15 dp, the float version to about 7dp
		In Fortran also notice when we set d we must specify 64-bit. In C literals are double precision by default
		
		What we set as 0.01 might not come out that way, and what we do see depends on formatting
		Summing a rather small number many times often doesn't give quite the expected result. This makes it risky as a loop condition as you can get 1 (or rarely more) fewer or extra loops depending on platform, optimisation levels etc
	
02 CombiningBigAndSmall.c : 	This code prints a variety of values found by summing floats. 
	In particular it sums small numbers onto a larger one. 
	Check what difference it makes to change eg_float to a double. What sort of value for init then makes the error a similar size to the array elements?


03 Overflows:

	Things to try:
		http://www.cplusplus.com/reference/climits/
		C only defines the minimum length of integer types. Normal ints must be at least 2 bytes but are nearly always 4. 
		There are also long ints, which (can be) longer than normal ints, and must be at least 4 bytes.
		Check the values of LONG_MIN and LONG_MAX and compare them to INT
		
		There are also short ints SHRT_MIN at least 2 bytes
		Since C99 there are long long ints which are at least 8 bytes. See if your system has LLONG_MIN and LLONG_MAX and if so, their sizes. 
		
		Unsigned ints don't have a sign so can be larger. Line 23 shows one gotcha with these types: what is it doing?
		
		Floating point numbers also have limits. 
		The IEEE (I triple-E) standards define strictly what behaviour must be. The program 03-05_InfAndNanTable.c shows the required values of operations on Inf and NaN (see also 05) values. 
		
		Note 1: Here FLT_MAX + 1 is still FLT_MAX because the finite Epsilon for a value this large is more than 1. Try finding the minimum needed to add to get inf
		
		Note 2: Here we are running into what are called denormal numbers. Usually the base part of the number is a number between 0.0 and 1.0 as in normal scientific notation. In denormal numbers this is a pure decimal. This allows the representation of smaller numbers, but at lower precision. 

04 MixedMode.c:	This program demos the dangers of combining int and float in a simple program
	Things to Try:
		In general operands are promoted to the "biggest" type involved in a single operation (biggest here means that ints will be boosted to longs, but can also be boosted to floats). Using the order of operations  (BODMAS, PEMDAS etc) work out what is happening. Note that the division operator "associates with" a number to its right. Note also that C doesn't guarantee 
		
		adjust the erroneous calculation on line 15 (C)/ 23 (Fortran)/ (Python) to be correct.
		
05 NaNContagion.c: This program explores NaN
	Things to Try:
		Using the facts about NaN comparisons implement the isNaN function at the end of the program. Test it with some numbers.
		Modern C (post 99) has an isNaN function in math.h and modern Fortran compilers support something similar but it is worth knowing how to quickly do your own
		
06 Uninitialised Errors.c: 
	
	Things to Try:
	
		This program does something a little subtle: it allocates an array, frees it, and then reallocates it. Depending on what has happened in the meantime, you may or may not happen to reallocate exactly the same block of memory. 
		Run the program, giving one integer between 0 and 100. 
		The first array should be the numbers 1 to 15. 
		This memory is now freed. 
		Next is an array of whatever size you entered. 
		Last is another array. 
		Depending on the sizes, sometimes one or other array gets that chunk of memory we just freed, and contains "data"
		
		Try also with optimisation on. You probably find the ``junk'' is more junky. 
		
		This sort of error is very hard to spot, and is a good reason to always initialise your variables!

		In Fortran there is an unintended intitialisation effect demo'd by the function total. Initialising in the declaration gives the running_total variable the "SAVE" attribute, which means it keeps its value between calls of the function. It looks like we properly initialised the value, but each time we call the function the result grows. Here the error is obvious: in practice it can be very tricky to spot
		
07 AccessErrors.c

	Things to try:
		This program has two chunks. Compiler with -DARR or -DBUFF to get them
		
		These sorts of errors are very unpredictable. The first part of this code (ARR) writes beyond it's array bounds. It randomly chooses to write to one of two arrays. On my system this alternates between an access violation, and overwriting the start of the next array. 

		The second part of the code (BUFF) tries to print a string missing a null-terminator. Usually you get the content of the string and then some junk, often unprintable characters shown as ``?''. 
		
		
08 BadPointer.c
		In this example you'll have to ignore the error about integer to pointer conversion.
		This code tries to access really bad memory, which is usually a seg-fault.
		

09 Tarpit.c
		This code has a logic bug which makes it very very slow. 
		
		If you compile and run, you'll see numbers printed. If it takes a very long time or no time at all, adjust the reps parameter
		
		The code is writing to a file, but accidentally opening it every iteration. You'll probably also notice the numbers go in pulses, when the writing actually flushes to disk. 

		Recompile the program with -DFIX and see how much faster it is without the unneeded work. 
		
		Run with the option `-q' to omit printing i at every step



