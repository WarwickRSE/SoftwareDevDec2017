DebugIntro
		
01 RoundingAndTruncation.c:	
		
02 CombiningBigAndSmall.c : 	This code prints a variety of values found by summing floats. 
	In particular it sums small numbers onto a larger one. 
	Check what difference it makes to change eg_float to a double. What sort of value for init then makes the error a similar size to the array elements?


03 Overflows:

	Things to try:
		http://www.cplusplus.com/reference/climits/
		C only defines the minimum length of integer types. Normal ints must be at least 2 bytes but are nearly always 4. 
		There are also long ints, which (can be) longer than normal ints, and must be at least 4 bytes.
		Check the values of LONG_MIN and LONG_MAX and compare them to INT
		
		There are also short ints SHRT_MIN at least 2 bytes
		Since C99 there are long long ints which are at least 8 bytes. See if your system has LLONG_MIN and LLONG_MAX and if so, their sizes. 
		
		Unsigned ints don't have a sign so can be larger. Line 23 shows one gotcha with these types: what is it doing?
		
		Floating point numbers also have limits. 
		The IEEE (I triple-E) standards define strictly what behaviour must be. The program 03-05_InfAndNanTable.c shows the required values of operations on Inf and NaN (see also 05) values. 

04 MixedMode.c:	This program demos the dangers of combining int and float in a simple program
	Things to Try:
		In general operands are promoted to the "biggest" type involved in a single operation (biggest here means that ints will be boosted to longs, but can also be boosted to floats). Using the order of operations  (BODMAS, PEMDAS etc) work out what is happening. Note that the division operator "associates with" a number to its right. Note also that C doesn't guarantee 
		
		adjust the erroneous calculation on line 15 to be correct.
		
05 NaNContagion.c: This program explores NaN
	Things to Try:
		Using the facts about NaN comparisons implement the isNaN function at the end of the program. Test it with some numbers.
		Modern C (post 99) has an isNaN function in math.h but it is worth knowing how to quickly do your own
		
06 Uninitialised Errors.c: 
	
	Things to Try:
	
		This program does something a little subtle: it allocates an array, frees it, and then reallocates it. Depending on what has happened in the meantime, you may or may not happen to reallocate exactly the same block of memory. 
		Run the program, giving one integer between 0 and 100. 
		The first array should be the numbers 1 to 15. 
		This memory is now freed. 
		Next is an array of whatever size you entered. 
		Last is another array. 
		Depending on the sizes, sometimes one or other array gets that chunk of memory we just freed, and contains "data"
		
		Try also with optimisation on. You probably find the ``junk'' is more junky. 
		
		This sort of error is very hard to spot, and is a good reason to always initialise your variables!
		
07 AccessErrors.c

	Things to try:
		This program has two chunks. Compiler with -DARR or -DBUFF to get them
		
		These sorts of errors are very unpredictable. The first part of this code (ARR) writes beyond it's array bounds. It randomly chooses to write to one of two arrays. On my system this alternates between an access violation, and overwriting the start of the next array. 

		The second part of the code (BUFF) tries to print a string missing a null-terminator. Usually you get the content of the string and then some junk, often unprintable characters shown as ``?''. 
		
		
08 BadPointer.c
		In this example you'll have to ignore the error about integer to pointer conversion.
		This code tries to access really bad memory, which is usually a seg-fault.
		

09 Tarpit.c
		This code has a logic bug which makes it very very slow. 
		
		If you compile and run, you'll see numbers printed. If it takes a very long time or no time at all, adjust the reps parameter
		
		The code is writing to a file, but accidentally opening it every iteration. You'll probably also notice the numbers go in pulses, when the writing actually flushes to disk. 

		Recompile the program with -DFIX and see how much faster it is without the unneeded work. 
		
		Run with the option `-q' to omit printing i at every step



