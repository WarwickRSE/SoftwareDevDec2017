
Actual commands are in (), see e.g. https://sourceware.org/gdb/onlinedocs/gdb/ for command details

For these first exercises, try the debugger BEFORE looking at the source code. The answers are quite easy to spot, but in real code they're less obvious, so you want to practice using the tool. 

ALWAYS start at the first error!!

GDB_eg1.c : trivial stack array bounds violation
		try without and with -g
		note that it's full of junk either way
		without -g we don't get a line number

		add a breakpoint on the print line (line 9)
		run the code and note it stops BEFORE running line 9
		now print i (p i) and a
		note i is 0 and a is garbage
		continue (continue) repeatedly until i=3
		check a, note we have successfully set each element to 0
		continue again, and should get a SIGTERM
		Notice that i is 3, i.e. beyond our array

		All that continuing is silly
		Remove the breakpoint from line 9(clear 9)
		Try using a condition (break 9 if i==3)
		Run again (If asked "The program being debugged has been started already.
Start it from the beginning? (y or n)" say y)
		
		Note that we knew where this fault was and used that info
		
		Quit the debugger (quit)

GDB_eg2.c : heap array bound violation
		In this one, just an out of bounds read doesn't cause a fault on my machine
		But a failure to allocate does
		
		Run the code. Note we see ``Program received signal SIGSEGV, Segmentation fault.'' 
		We can then get a backtrace with bt
		And we can print the value of i, and see this is the 0th iteration
		We can print a too. I see 0x0 which is clearly a bad pointer
		Putting those last facts together we can infer that the error comes when we access a at all, i.e. a is bad. 
		Add back code line 9 to allocate `a' properly
		
		Note that the bad array bound ISNT CAUGHT!
		
		
		Notice that gdb helps us locate WHERE the error is, but doesn't help us tell where it came from. Other tools help more

GDB_eg3.c : A silly wrapper function to demo function named breakpoints and scope
		
		run the code, note that we get -ve arguments hence NaN
		set a conditional breakpoint on entering my_sqrt (break my_sqrt if input < 0)
		run the code
		it stops and we see that input was -3
		BUT can't see the values in main that got us here
		Get a backtrace (bt) - we came straight from main
		We have to return to the correct ``frame'' (gls{frame}) here 1 (frame 1 or up)
		Can see all local variables and values now! (info locals)
		See that this was i=0 iteration
		Continue!
		Next bad value is -1 at i=3
		In a real program, this would be useful info to work out WHY our input is going negative. Of course, in this case, we can simply examine inside get_x and see.
		
GDB_eg4.c : A simple binary search in ordered list of integers, with various bugs. Uses fixed size arrays, randomly filled

	run the code a few times. Note that we get a random array, although always increasing. By default the target value is 5. Supply a number at command line to search for it (>> ./eg4 6)
		
	There's some helpful compiler flags in this code (ifdef /ifndef) Find them and see what they do. (Hint, there's some extra output, and around line 53 a very useful change)
	Note line 6 which sets the array size: even numbers, powers of 2 etc will have significant effects in this code. 
	
	IN C: If your compiler hasn't already warned you of one bug, turn on all warnings (-Wall in gcc)
	In Fortran: Use the array bounds checking 
	
	BUGS:
		Array definition has size-1 not size
		C ONly: index is unsigned, but fill_array returns -1 for not found. Bonus that the check fails, but the print shows -1 because it's a signed format code
		Loop on line 78 (C) 104 (Fortran) is fine unless array_size is 1, i which case we get no iterations
		Bug that debugger wont spot: (C) atoi to set target wont care if you don't enter an int (Fortran) We don't check our input, so we'll get something but might not be sane
		
	
	
	
	
	

Valgrind Examples

Val_eg1.c : Heap array bounds violation
	This is the same as GDB_eg2, but the array is allocated so we just have the bounds problem and I have added a second error, where we take a pointer to an array element and forget we have freed it
	
	On my machine this actually runs fine, but sometimes it can crash, so we always want to check for things like this. 
	
	Compile and run the code inside Valgrind using (valgrind {name}). Don't forget the debugging symbols, and to turn off optimisation
	
	START at the FIRST error
	You should see something like 
		Invalid write of size 4. 
	This says we're reading 4 bytes (an int) from memory we didn't allocate
	Notice that it also says 
		Address 0xabcabcabc is 0 bytes after a block of size 40 alloc'd
	This tells us the bad value we're trying to access is right after a block of size 40 we _did_ allocate
	Next is
		Invalid read of size 4
	which tells us we're now reading this value back
	Finally I get one more invalid read, for 3 total errors
	
	On my machine, when I turn on optimisation (O1) Valgrind finds only 2 errors: the invalid read of a[10] is no longer noticed!
	
	Fix the cause of the first error(s), the invalid access on `a'
	
	Now examine that last message
		Invalid read of size 4
		....
		Address 0x1007ff994 is 20 bytes inside a block of size 40 free'd
	This tells us that we are accessing into some memory we already freed. Specifically we are 20 bytes (5 ints) into it. 
	The cause is easy to spot, rand_ptr = &a[5];

	Fix the free and the program works as intended
	

Val_eg2.c : Unitialised value
	We revisit the sum functions from Yesterday's session: generate some random numbers and then sum them.
	Run the program a few times
	Try with (at least) O0 and O3. Is there any differences? Either between runs or O levels


	Sometimes Valgrind can be ``fooled'': try adding back the print in line 32, and rerun. I see a lot of errors, 
		Syscall param write(buf) points to uninitialised byte(s)
	all traced to printing the sum_a on line 31
	Note that the report has hundreds of errors for a single bad print here. 	
	You might be tempted to remove the print: try this. Why doesn't it help you?
	
	Once again, Valgrind tries to help
		Use --track-origins=yes to see where uninitialised values come from
	When we do this, we see that the bad value was created in the sum function.
	Sadly I don't get anything more useful than that, but I can go to the source code and see the problem

val_eg3.c : Memory Leak
	Here we create a memory leak and some other issues
	
	Compile and run the program. You probably don't get any crashes or errors. What it _should_ do is (slowly) print 5 different arrays. 
	Neither valgrind nor GDB will show you why all 5 arrays are the same. You'll have to look into the code
	
	Once you've fixed that, try running the program inside valgrind (remember to turn off optimisation etc). 
	You wont see an error but should see something like 
		LEAK SUMMARY:
==45574==    definitely lost: 200 bytes in 5 blocks
	near the end. 
	You should also have a line
		Rerun with --leak-check=full to see details of leaked memory
	Obey the line. It points us to where the leaking memory is allocated (not where it gets lost)
	If you solved the random elements problem, it should be fairly obvious why we have a leak. (Hint: what happens to the array from the previous iteration?)
	Fix the leak, and check it's fixed
		
	
Profiling Examples:

Prof_branch.c: This demos branch prediction. It may or may not work, since some architectures manage to predict even these branches. 
	In theory, you should see that the normal version takes a given time, the one with -DBR_1 very similar time, and -DBR_2 and -DBR_3 take rather longer. The similar times in the first two show it is not the sum calculation changing the timing, but the misses. If you are on a machine with a tool like perf you can run a basic stats using
	perf stats {program_name}
	IF you saw speed differences, you will probably see varying numbers under ``branch-misses             #    0.00% of all branches ''
		